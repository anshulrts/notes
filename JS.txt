JS
Static vs Dynamic Type Check
JS is a dynamic type checking language. Dynamic Programming language is a class of high level programming lang in which type checking occurs at runtime.
These languages are usually not compiled but are interpreted.
In Static type checking languages, the type checking occurs at compile time.

Strong & Weak Type
Strong type - The type of an object can't change
Weak type - it can change. Also type coercion is allowed, so language makes conversions between unrelated types implicitly. Eg print (1 + "2") would print the result as 12
JS is weakly typed language.
Python is a dynamic language, but strong type

window object
It is an interface which represents a window in browser. An object of window is automatically created by the browser.
window is the object of browser and not JS. When we do "alert" or "confirm" in JS code, we are calling the properties of window object.
One of the other such property is document, which points to the DOM document.
Even the console.log() is available because window.console is a property.

Document
It is an interface or root element which represents any web page loaded in the browser and serves as an entry point into the web page's content, which is a DOM tree.
The DOM tree includes elements such as <body>, <table>, <div> etc.
When HTML document is loaded in the browser, it becomes a document object. We can use this object to add dynamic content to our web page.
window.document is same as document.

Execution Context
EC in JS is the environment in which JS code is executed. It contains info about current scope, variables & functions.
Each time a function is called, a new execution context is created. And it is destroyed when the function returns.
To keep track of all the contexts, the JS engine uses a call stack. It uses LIFO
There are broadly 2 execution context in JS:
Global EC - This is for Global Scope. It's created when the JS engine starts.
Function EC - This is for a function. It is created when a function is called.
At the very beginning of JS script execution, the JS engine executed the entire source code, creates a Global EC, and then does the following things:
1. Creates a global object that is window in the browser and global in NodeJS.
2. Sets up a memory for storing variables and functions.
3. Stores the variables with values as undefined and function references.
After this creation phase, the EC will move to the code execution phase.

First class Functions
A prog lang is said to have First Class Functions when functions in that lang are treated like any other variable. For e.g, in such language, a function can be passed as argument to other functions, can be returned by other functions, and can be assigned as a value to a variable.

Callback function
A callback function is a function passed into another function as an argument, which is then invoked inside the the outer function.
They can be called synchronously or asynchronously. Example setTimeout() calls it async, where as Array.prototype.map() calls it sync.



JS Non Primitive Types
There are 3 non primitive types:
Object
Array
RegExp

Object
An object is a reference data type. In JS, objects are the only mutable values. Functions are also objects with the additional capability of being callable.
This is how we create objects in JS:
let school = {
    name: 'BBPS',
    established: '1946',
    location: 'Delhi'
    displayInfo: function() {
        console.log(`${school.name} was established in ${school.established} at ${school.location}`);
    }
}
school.displayInfo();
or
const obj1 = new Object();
obj1.property1 = 42;
console.log(obj1.property1); // dot notation
console.log(obj1['property1']) // bracket notation

Loosely speaking, objects in JS may be defined as an unordered collection of related data, of primitive or reference types, in the form of "key:value" pairs.
These keys can be variables or functions and are called properties and methods respectively.
The property names can be strings or numbers. In case they are numbers, they must be accessed using "bracket notation"
We can use for..in to operate over all the keys of an object, if they are enumerable.

Global Object
A GO is an object that always exist in the global scope. In a web browser, when scripts create global variables defined with the var keyword, they're created as members of the global object.
The global object's interface depends on the execution context in which the script is running. For e.g:
- In a web browser, any code which the script doesn't specifically startup as a background task has a 'window' as its global object.
- Code running in a worker has workerglobalscope as its global object.
- Scripts running under NodeJS have an object called 'global' as their global object.

this
The 'this' keyword refers to the context where a piece of code is supposed to run. Typically, they are used in object methods,
where 'this' refers to the object that the method is attached to, thus allowing the same method to be reused on different objects.
The value of this in javascript depends on how a function is invoked (runtime binding), not how it is defined.
When a regular function is invoked as a method of an object, 'this' points to that object.
When invoked as a standalone function, 'this' typically refers to the global object (in non-strict mode) or undefined (in strict mode).
The methods bind(), apply() and call() can set the 'this' value for a particular call.
Arrow function differ in their handling of 'this': they inherit 'this' from the parent scope at the time they are defined.
This behaviour makes arrow function particularly useful for callbacks and preserving context. However, their 'this' value cannot se set by
bind(), apply() and call() methods, nor does it point to the current object in object method.
Refer - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this



== vs === (Loose vs Strict equality comparison)
They both are used to check equality between 2 values or variables.
Difference is in how they compare values. The == operator compares the values of 2 variables after performing type conversion if necessary.
=== operator compares the values of 2 variables without performing type conversion.
Eg.
const num = 10;
const str = "10";

console.log(num == str); // true
console.log(num === str); // false

It is important to understand that the actual values remain unchanged. It only implicitly gets converting while comparing.

Exceptional case
const a = true;
const b = 'true';
console.log(a == b); // false, because during coercion, if either operand is a boolean, it will be converted to a number (true becomes 1 and false 0)

So, here are the rules for type coercion in JavaScript:
If either operand is a string, the other operand will be converted to a string.
If either operand is a number, the other operand will be converted to a number.
If either operand is a boolean, it will be converted to a number (true becomes 1 and false becomes 0).
If one operand is an object and the other is a primitive value, the object will be converted to a primitive value before the comparison is made.
If one of the operands is null or undefined, the other must also be null or undefined to return true. Otherwise it will return false.

Facts about JS
- JS is case sensitive and uses Unicode character set.
- A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.
- It has 3 kinds of variable declarations, var, let, const.
- JS is a single threaded interpreted lang.
- In expressions involving string and int with + operator, int is converted to string. Eg 42 + " is the answer" prints "42 is the answer" and "37" + 7 prints 377
- In case there is a variable which is string, but stores a number, use parseInt()
- How to use a normal method as constructor in vanilla javascript (before es6)? using 'new' and 'this' keyword